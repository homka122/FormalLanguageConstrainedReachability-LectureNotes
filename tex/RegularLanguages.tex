\setchapterpreamble[u]{\margintoc}
\chapter{Регулярные языки}
\tikzsetfigurename{RegularLanguages_}

В данном разделе мы обсудим регулярные языки~--- класс, лежащий на самом нижнем уровне иерархии Хомского.
Несмотря на то, что это один из самых простых классов, он является, пожалуй, самым применимым на практике и используется, например, для задания шаблонов поиска в тексте, в анализе языков, для верификации программного обеспечения, для задания шаблонов путей при анализе графов, и во многих других областях.
Будут рассмотрены основные способы задания таких языков: \emph{регулярные выражения}, \emph{конечные автоматы}, \emph{лево(право)линейные грамматики}.
Обсудим основные свойства регулярных языков, такие как замкнутость относительно различных операций, а также различные свойства соответствующих автоматов и грамматик.
Определим производные для регулярных языков, сформулируем \emph{лемму о накачке}.

Стоит отметить, что рассматриваться будут лишь базовые конструкции, алгоритмы и их свойства.
Многие фундаментальные результаты можно найти, например, в книге <<Introduction to Formal Language Theory>>~\cite{10.5555/578595}, а для более глубокого изучения области можно обратиться, например, к книге <<Handbook of Automata Theory>>~\cite{DBLP:books/ems/21/P2021}.


\section{Регулярные выражения}

Регулярные выражения~--- один из часто применяющихся на практике классических способов задать регулярный язык%
\sidenote{
    Замечание для программистов.
    Важно понимать, что речь идёт о формальной конструкции, а не о том, что называется регулярными выражениями в различных языках программирования, библиотеках, инструментах, где под названием \enquote{регулярные выражения} могут скрываться конструкции, существенно более выразительные, чем обсуждаемые здесь.
}.
Основывается этот способ на предложении синтаксиса для описания \emph{регулярных множеств}%
\sidenote{Помним, что язык~--- это множество слов.}.

\begin{definition}[Регулярное множество]
    Регулярное множество (над алфавитом $\Sigma$) это:
    \begin{itemize}
        \item $\varnothing$ или пустое множество;
        \item $\{\varepsilon\}$ или множество, состоящее только из пустой цепочки;
        \item $\{t\}$, $t \in \Sigma$ или множество, состоящее из одного символа из алфавита;
        \item $R_1 \cup R_2$ или объединение множеств, где $R_1$ и $R_2$~--- регулярные множества;
        \item $R_1 \cdot R_2$ или конкатенация множеств, где $R_1$ и $R_2$~--- регулярные множества;
        \item $R^*$ или замыкание Клини, где $R$~--- регулярное множество.
    \end{itemize}
\end{definition}

Для того, чтобы описывать такие множества, можно пользоваться \emph{регулярными выражениями}, которые, фактически, предоставляют синтаксис для описания операций над регулярными множествами, представленными выше.

\begin{definition}[Регулярное выражение]
    Регулярное выражение (над алфавитом $\Sigma$) это:
    \begin{itemize}
        \item пустое множество $\varnothing$;
        \item множество из пустой цепочки $\varepsilon$;
        \item множество из одного символа $t$, $t \in \Sigma$;
        \item объединение регулярных выражения (множеств) $R_1 \mid R_2$, где $R_1$ и $R_2$~--- регулярные выражения;
        \item конкатенация регулярных выражения (множеств) $R_1 \cdot R_2$, где $R_1$ и $R_2$~--- регулярные выражения;
        \item замыкание клини $R^*$, где $R$~--- регулярное выражение;
        \item группирующие скобки $(R)$, где $R$~--- регулярное выражение.
    \end{itemize}
\end{definition}

Отметим несколько важных с прикладной точки зрения моментов.
Во-первых, часто используется расширенный синтаксис, в который добавляются конструкции не увеличивающие выразительную силу, но упрощающие запись.
Например, встречаются следующие расширения%
\sidenote{
    Существуют и другие, однако их мы не будем использовать и, соответственно, рассматривать.
    Читатель может вспомнить, что называется регулярными выражениями в его любимом языке программирования и попробовать самостоятельно выразить имеющиеся там конструкции через базовые.}.
\begin{itemize}
    \item $R? = R \mid \varepsilon$, где $R$~--- регулярное выражение.
    \item $R^+ = R \cdot R^*$, где $R$~--- регулярное выражение.
\end{itemize}

Во-вторых, конструкции $\varnothing$ и $\varepsilon$ используются крайне редко, особенно в случае расширенного синтаксиса, так как часто выражение, эквивалентное использующему данные конструкции, более компактно записывается с использованием расширенного синтаксиса.
В-третьих, оператор конкатенации часто опускается%
\sidenote{Как и знак умножения во многих математических записях.}.

Рассмотрим несколько примеров регулярных выражений.
\begin{example}
    Регулярное выражение $a$ задаёт регулярное множество $\{a\}$ и, соответственно, язык из единственного слова $a$.
\end{example}


\begin{example}
    Регулярное выражение $ab$ задаёт регулярное множество $\{ab\}$ и, соответственно, язык из единственного слова $ab$.
\end{example}


\begin{example}\label{exmpl:regexp_a_star}
    Регулярное выражение $a^*$ задаёт регулярное множество \[R = \bigcup_{i=0}^{\infty}{a^i} = \{\varepsilon, a, aa, aaa, \ldots \}\] и, соответственно, бесконечный язык, содержащий для любого неотрицательного целого $n$ цепочку из символов $a$ длины $n$.
\end{example}

\begin{example}
    Регулярное выражение $a^*b$ задаёт бесконечный язык, содержащий цепочки, полученные конкатенацией цепочек из языка, описанного в примере~\ref{exmpl:regexp_a_star} и символа $b$.
    Иными словами, любая цепочка из языка выглядит как последовательность символов $a$ произвольной длины (возможно пустая), за которой следует символ $b$.
    Примеры цепочек из языка: $b, ab, aaab, aaaaab$.
\end{example}

\begin{example}
    Регулярное выражение $(a\mid b)^*$ задаёт бесконечный язык, цепочки которого имеют произвольную длину и состоят из символов $a$ и $b$ в произвольном порядке.
    Примеры цепочек из языка: $\varepsilon, a, aa, b, ba, aba$.
\end{example}

\begin{example}
    Регулярное выражение\sidenote{Здесь мы воспользовались расширенным синтаксисом.} $(ab)^*c?$ задаёт бесконечный язык, цепочки которого состоят их произвольного количества повторений подпоследовательности $ab$ за которой может следовать (но не обязательно следует) символ $c$.
    Примеры цепочек из языка: $\varepsilon, abab, abc, abababc$.
\end{example}

\section{Конечные автоматы}

\emph{Конечный автомат} (Finite State Machine, FSM)~--- вычислительная машина, которая имеет конечный набор состояний и может совершать переходы между ними, основываясь на прочитанных входных данных.
Важно отметить, что ни какой дополнительной памяти классический конечный автомат не имеет и дополнительных действий (кроме чтения входной ленты) не производит %
\sidenote{Cуществуют автоматы с записью на отдельную (выходную) ленту (например, автоматы Мили~\cite{6771467}) и другие, основанные на конечных автоматах, вычислители, производящие дополнительные действия.
Например, расширенные конечные автоматы (Extended Finite State Machine), которые умеют работать с памятью (переменными)~\cite{Alagar2011, foster.ea:efsm:2020}.}.

Автоматом самого общего вида является \emph{недетерминированный конечный автомат}. 
\begin{definition}[Недетерминированный конечный автомат]
    \label{def:NondeterminicticFiniteAutomata}
    \emph{Недетерминированный конечный автомат} (НКА, Nondeterministic Finite Automaton, NFA)~--- это пятёрка $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$, где
    \begin{itemize}
        \item $Q$~--- конечное множество состояний, $Q \neq \varnothing$;
        \item $Q_S \subseteq Q$~--- множество стартовых состояний, $Q_S \neq \varnothing$;
        \item $Q_F \subseteq Q$~--- множество финальных состояний\sidenote{Обатите внимание, множества стартовых и финальных состояний могут перескаться.}, $Q_F \neq \varnothing$;
        \item $\delta \subseteq Q \times (\Sigma \cup \varepsilon) \times 2^Q$~--- функция переходов, а $\varepsilon \notin \Sigma$;
        \item $\Sigma$~--- конечный алфавит.
    \end{itemize}
\end{definition}

Заметим, что функцию переходов можно представить разными способами: это может быть множество троек вида $(q_i, t, q_j)$, матрица, или же граф с метками на рёбрах 
\[G = \langle Q, \{(q_i,t,q_j \mid q_j \in \delta(q_i,t))\}, \Sigma \rangle.\]
В дальнейшем мы чаще всего будем использовать представление автомата в виде графа.
Чтобы такое представление было полным, в графе отдельно обозначают стартовые и финальные состояния, как это показано на рисунках~\ref{fa:start_state} и~\ref{fa:final_state} соответственно.
\begin{marginfigure}    
    \begin{center}
        \begin{tikzpicture}
            \node[state,initial] (q_0)  {$q_s$};
        \end{tikzpicture}
    \end{center}
    \caption{Пример обозначения стартового состояния $q_s$}
    \label{fa:start_state}
\end{marginfigure}
\begin{marginfigure}    
    \begin{center}
        \begin{tikzpicture}
            \node[state,accepting] (q_0)  {$q_f$};
        \end{tikzpicture}
    \end{center}
    \caption{Пример обозначения финального состояния $q_f$}
    \label{fa:final_state}
\end{marginfigure}

Так как нас интересуют конечные автоматы в контексте языков, то будем говорить, что на ленте автомата записано какое-то слово (или строка).
Иными словами, будем говорить, что автомат принимает на вход слово или строку.
При таком подходе автомат естественно рассматривать как \emph{распознователь}\sidenote{Конечно, на автомат можно смотреть и как на генератор: любой путь от сартового состояния до финального задаёт слово из языка.}.

\begin{example}
    Пусть задан автомат $M=\langle Q, Q_S, Q_F, \delta, \Sigma\rangle$, где
    \begin{itemize}
        \item $Q = \{0,1,2\}$;
        \item $Q_S = \{0\}$;
        \item $Q_F = \{1\}$;
        \item $\Sigma = \{a,b\}$;
        \item $\delta$ определена следующим образом\sidenote{Часто указывают только те случаи, в которых $\delta$ возвращет непустое множество. Тогда для неуказанных входных аргументов $\delta$ возвращает пустое множество.}: 
        \begin{alignat*}{6}
            \delta(0,a) =& \{0,1\}      \qquad    & \delta(1,a) =& \varnothing \qquad & \delta(2,a) =& \varnothing \\
            \delta(0,b) =& \varnothing           & \delta(1,b) =& \{2\}             & \delta(2,b) =& \{1\} \\
            \delta(0,\varepsilon) =& \varnothing & \delta(1,\varepsilon) =& \{0\}   & \delta(2,\varepsilon) =& \varnothing.
        \end{alignat*}
    \end{itemize}
    Тогда его можно представить в виде графа как показано на рисунке~\ref{fa:fa_example}.
    \begin{marginfigure}    
        \begin{center}
            \begin{tikzpicture}
                \node[state,initial] (q_0) {$0$};
                \node[state,accepting] (q_1) [right = of q_0] {$1$};
                \node[state] (q_2) [above = of q_1] {$2$};
                \path[->]
                    (q_0) edge[bend left, above]   node {$a$} (q_1)
                    (q_0) edge[loop above, above]   node {$a$} (q_0)
                    (q_1) edge[bend left, left]   node {$b$} (q_2)
                    (q_2) edge[bend left, right]   node {$b$} (q_1)
                    (q_1) edge[bend left, below]  node {$\varepsilon$} (q_0);
            \end{tikzpicture}
        \end{center}
        \caption{Пример конечного автомата}
        \label{fa:fa_example}
    \end{marginfigure}
\end{example}

Процесс вычислений, проделываемых конечным автоматом, удобно описывать в терминах переходов между \emph{конфигурациями}.

\begin{definition}[Конфигурация]
    Конфигурация $c$ конечного автомата $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$~--- это пара $(q, w)$, где $q\in Q$~--- это текущее состояние автомата, а $w \in \Sigma^*$~--- непросмотренная часть входной строки.
\end{definition}

\begin{definition}[Переход в НКА]
    Будем говорить, что автомат $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$ может перейти из конфигурации $c_1 = (q_1, w_1)$ в конфигурацию $c_2 = (q_2, w_2)$, если
    \[c_2 \in \{(q_2,w_2) \mid w_1 = aw_2, (q_1,a, q_2) \in \delta\} \cup \{(q_2,w_1) \mid (q_1, \varepsilon, q_2) \in \delta\}.\]
    Обозначать этот факт будем как $c_1 \to c_2$.
    Также будем считать, что на множестве конфигураций задано отношение перехода $(\to):(Q \times \Sigma^*)\times(Q \times \Sigma^*)$.
    
\end{definition}

\begin{definition}
    Транзитивное рефлексивное замыкание отношения перехода на конфигурациях будем обозначать следующим образом: \[ c_1 \to^* c_2. \]
    Альтернативно, в случае если $c_1 \to^* c_2$, будем говорить, что конфигурация $c_2$ \textit{достижима} из конфигурации $c_1$.
\end{definition}

Для удобства работы с недетерминированными автоматами расширим это отношение на множество конфигураций.

\begin{definition}
Будем говорить, что автомат может перейти из множества конфигураций $C_1$ в множество конфигураций $C_2$, если 
\[C_2 = \bigcup_{c_1 \in C_1} \{c_2 \mid c_1 \to c_2 \}.\]

Обозначать этот факт будем как  $C_1 \Rightarrow C_2 $.
\end{definition}

\begin{definition}
Транзитивное рефлексивное замыкание отношения перехода на множествах конфигураций будем обозначать следующим образом: \[ C_1 \Rightarrow^* C_2. \]
\end{definition}

Для описания работы автомата $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$ нам понадобятся следующие выделенные типы конфигураций.
\begin{itemize}
    \item Стартовая конфигурация $c_s = (q_s,w)$, $q_s \in Q_S$, $w$ --- цепочка, которая подаётся на вход автомату. 
    Для недетерминированного автомата естественно задать множество стартовых конфигурация $C_S = \bigcup_{q_s \in Q_S} (q_s,w)$.
    \item Финальная (принимающая) конфигурация $c_f = (q_f,\varepsilon)$, $q_f \in Q_F$.
\end{itemize}

Таким образом, работу автомата можно описать как последовательность переходов между множествами конфигураций. 
Работа начинается с множества стартовых конфигураций и завершается в следующих двух случаях.
\begin{enumerate}
    \item Очередное множество конфигураций содержит финальную конфигурацию:
    \[C_S \Rightarrow^* C_i, c_f \in C_i.\] В этом случае говорят, что автомат \textit{принимает} входную строку.
    \item Очередное множество конфигураций пусто:
    \[C_0 = C_S \Rightarrow^* C_i \Rightarrow^* \varnothing, \text{ для любого } i: c_f \notin C_i.\] 
    В этом случае говорят, что автомат \textit{не принимает} или \textit{отвергает} входную строку.
\end{enumerate} 

\begin{definition}
    Язык задаваемый недетерминированным конечным автоматом $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$~--- это множество слов, принимаемых им:
     \[ \{w \mid (q_s,w) \to^* (q_f,\varepsilon), q_s \in Q_S, q_f \in Q_F \}.\]
\end{definition}

Так как конфигурация полностью описывает состояние процесса вычислений, то не надо обрабатывать одну и ту же конфигурацию несколько раз. 
Это поможет при написании реального интерпретатора. 
Будем отслеживать уже посещённые (обработанные) конфигурации\sidenote{Техника, аналогичная той, что применяется в обходах графов (обход в ширину, обход в глубину) для того, чтобы избежать повторного посещения вершин и, как следствие, зацикливания обхода. Более того, она типична для алгоритмов с рабочим множеством.}. 

\begin{example}
    Пример интерпретации конечного автомата.
\end{example}

\begin{definition}[Детерминированный конечный автомат]
    \label{def:DeterminicticFiniteAutomata}
    \emph{Детерминированный конечный автомат} (ДКА, Deterministic Finite Automaton, DFA)~--- это пятёрка $M = \langle Q, q_S, Q_F, \delta, \Sigma \rangle$, где
    \begin{itemize}
        \item $Q$~--- конечное множество состояний, $Q \neq \varnothing$;
        \item $q_S \in Q$~--- стартовое состояние;
        \item $Q_F \subseteq Q$~--- множество финальных состояний\sidenote{Обатите внимание, стартовое состояниеможет входить в множество финальных.}, $Q_F \neq \varnothing$;
        \item $\delta \subseteq Q \times \Sigma \times Q$~--- функция переходов\sidenote{При данном определении автомат будет ещё и \emph{полным}: для каждого состояния и каждого символа определён переход. Часто встречается вариант, когда функция переходов частично определёна: для некоторых состояний не определены переходы для некоторых символов.};
        \item $\Sigma$~--- конечный алфавит.
    \end{itemize}
\end{definition}

Основных отличий от недетерминированного автомата два.
Во-первых, стартовое состояние ровно одно.
Во-вторых,  функция переходов не допускает переходов по $\varepsilon$ и из любого состояния существует не более одного перехода по конкретному символу.

\begin{example}
    Пример КА.
    % \begin{tikzpicture}

    % \end{tikzpicture}
\end{example}

\begin{example}
    Пример интерпретации конечного автомата.
\end{example}

\section{Производные для регулярных языков}

Предложены в~\sidecite{Brzozowski1964}

По мотивам~\sidecite{OWENS_REPPY_TURON_2009}

\begin{itemize}
    \item $\partial_t(\varepsilon) = \varnothing$
    \item $\partial_t(\varnothing) = \varnothing$
    \item $\partial_t(x) = $
    \item $\partial_t(R_1 \cdot R_2) = \partial_t(R_1) \cdot (R_2) \mid $
    \item $\partial_t(R_1 \mid R_2) = \partial_t(R_1) \mid \partial_t(R_2) $
    \item $\partial_t(R^*) = $\sidenote{Интересное упражнение --- показать это, расписав по определению звезду Клини.}
\end{itemize}

Проверка на пустоту (часто isNull).

\begin{itemize}
    \item $IsNull(\varepsilon) = false$
    \item $\partial_t(\varnothing) = \varnothing$
    \item $\partial_t(x) = $
    \item $\partial_t(R_1 \cdot R_2) = \partial_t(R_1) \cdot (R_2) \mid $
    \item $\partial_t(R_1 \mid R_2) = \partial_t(R_1) \mid \partial_t(R_2) $
    \item $\partial_t(R^*) = $\sidenote{Интересное упражнение --- показать это, расписав по определению звезду Клини.}
\end{itemize}

Проверка пустоты регулярного языка\sidenote{Отдельное решение не на производных.}


\section{Построение конечного автомата по регулярному выражению}
 
На производных%
\sidenote{Существуют и другие алгоритмы построения автомата по регулярному выражению. Например, алгоритм Томпсона~\cite{10.1145/363347.363387} или алгоритм Глушкова~\cite{Glushkov1961}.
Как правило, каждый алгоритм строит автомат со специфичными свойствами: детерминированный или нет, с $\varepsilon$-переходами или без них.}.

Каждое состояние соответствует языку, распозноваемому из этого состояния.

Стартовое --- исходное регулярное выражение. Далее в цикле. 
Берём очередное необработанное состояние, по каждому символу из алфавита берём производную соответствующего ему регулярного выражения.
Добавляем получившееся состояние (если ещё не было такого).
Если состояние isNullable, то помечаем его финальным.
Добавляем ребро.

В результате получим полный детерминированный конечный автомат\sidenote{Формально можно получить минимальный, но на практике это сложно. Но часто всё же достаточно близко к минимальному получается.}.  

Примеры.


\section{Построение регулярного выражения по конечному автомату}

Алгоритм Клини(?)
Регулярное выражение будем строить по недетерминированному автомату специального вида: потребуем, чтобы у него было ровно одно стартовое состояние и ровно одно финальное%
\sidenote{Любой автомат можно привести к такому виду. 
Предположим, что в автомате два стартовых состояния $q_0^s$ и $q_1^s$.
Добавим новое сотояние $q_s$, назначим его стартовым, добавим переходы $q_s \xrightarrow{\varepsilon} q_0^s$ и $q_s \xrightarrow{\varepsilon} q_1^s$, уберём $q_0^s$ и $q_1^s$ из стартовых.
Аналогично можно поступить и с финальными состояниями.}. 
\begin{marginfigure}    
    \begin{center}
        \begin{tikzpicture}

            \node[state] (q_0)                   {$q_i$};
            \node[state] (q_1) [right = 1.8 of q_0]  {$q_j$};

            \path[->]
                (q_0) edge[bend left = 45, above]   node {$R_1$} (q_1)
                (q_0) edge[above]   node {$R_2$} (q_1)
                (q_0) edge[bend right, below]  node {$R_3$} (q_1);

        \end{tikzpicture}
    \end{center}
    \caption{Два состояния с параллельными рёбрами}
    \label{fa:fa1}
\end{marginfigure}
\begin{marginfigure}
    
    \begin{center}
        \begin{tikzpicture}

            \node[state] (q_0)                    {$q_i$};
            \node[state] (q_1) [right = 1.8 of q_0]  {$q_j$};
            
            \path[->]
                (q_0) edge[above]  node {$R_1 \mid R_2 \mid R_3$} (q_1);

        \end{tikzpicture}
    \end{center}
    \caption{Результат объединения параллельных рёбер для состояний, представленных на рисунке~\ref{fa:fa1}}
    \label{fa:fa2}
\end{marginfigure}

Будем в цикле выполнять последовательно две операции.
\begin{enumerate}
    \item Объединение параллельных рёбер.
    \item Устранение состояния $v$. За один шаг можем устранить любое состояние кроме стартового или финального.
\end{enumerate}
Цикл повторяется до тех пор, пока в автомате не останется ровно два состояния: стартовое и финальное.
После завершения цикла необходимо ещё раз объединить параллельные рёбра. 
После этого, по полученному автомату можно построить итоговое регулярное выражение.

Параллельные рёбра вида $p_i \xrightarrow{R_1} q_i, \ldots, p_i \xrightarrow{R_k} q_i$ объединяются в одно ребро вида $p_i \xrightarrow{R_1 \mid \ldots \mid R_k} q_i$, метка которого --- объединение всех регулярных выражений с параллельных рёбер.
Пример такого объединения приведён на рисунках~\ref{fa:fa1} и~\ref{fa:fa2}.

Операция устранения состояния $v$ устроена следующим образом. 
Рассмотрим три типа рёбер.
\begin{enumerate}
    \item Рёбра вида $p_i \xrightarrow{R_{p_i}} v$, где $p_i \neq v$.
    \item Рёбра вида $v \xrightarrow{R_{q_j}} q_i$, где $q_i \neq v$.
    \item Рёбра вида\sidenote{Рёбер такого вида для заданной вершины всегда не более одного, так как мы производим объеднинение параллельных рёбер на каждой итерации алгоритма.} $v \xrightarrow{R_v} v$.
\end{enumerate}

В результате устранения состояния $v$ все рассмотренные рёбра должны быть удалены. 
Взамен них должны быть добавлены рёбра вида $p_i \xrightarrow{R_{p_i} \cdot R_v^* \cdot R_{q_j}} q_j$.
Пример описанного преобразования представлен на рисунках~\ref{fa:fa3} и~\ref{fa:fa4} 

\begin{figure}
    \begin{center}
        \begin{subfigure}[b]{0.47\textwidth}
            \begin{center}
                
                \begin{tikzpicture}

                \node[state] (p_0)          {$p_0$};
                \node[text width=0.3cm]  (p_1) [below = 0.3 of p_0] {$\vdots$}; 
                \node[state] (p_2) [below = 0.3 of p_1]  {$p_i$};
                \node[text width=0.3cm] (p_3) [below = 0.3 of p_2]  {$\vdots$};
                \node[state] (v_0) [right = of  p_2] {$v$};
                \node[state] (q_2) [right = of v_0] {$q_j$};
                \node[text width=0.3cm] (q_1) [above = 0.3 of  q_2]  {$\vdots$};
                \node[state] (q_0) [above = 0.3 of q_1]  {$q_0$};
                \node[text width=0.3cm] (q_3) [below = 0.3 of q_2]  {$\vdots$};

                \path[->]
                    (p_0) edge[above]  node {$R_{p_0}$} (v_0)
                    (p_2) edge[below]  node {$R_{p_i}$} (v_0)
                    (v_0) edge[left]  node {$R_{q_0}$} (q_0)
                    (v_0) edge[below]  node {$R_{q_j}$} (q_2)
                    (v_0) edge[loop above, above]  node {$R_v$} (v_0);

                \end{tikzpicture}
            \end{center}
        
            \caption{Автомат перед устранением состояния $v$}
            \label{fa:fa3}

        \end{subfigure}\hspace{5mm}
        \begin{subfigure}[b]{0.47\textwidth}
            \begin{center}

                \begin{tikzpicture}

                    \node[state] (p_0)          {$p_0$};
                    \node[text width=0.3cm]  (p_1) [below = 0.3 of p_0] {$\vdots$}; 
                    \node[state] (p_2) [below = 0.3 of p_1]  {$p_i$};
                    \node[text width=0.3cm] (p_3) [below = 0.3 of p_2]  {$\vdots$};
                    
                    \node[text width=0.3cm] (v_0) [right = of p_2] {};

                    \node[state] (q_2) [right = of v_0] {$q_j$};
                    \node[text width=0.3cm] (q_1) [above = 0.3 of q_2]  {$\vdots$};
                    \node[state] (q_0) [above = 0.3 of q_1]  {$q_0$};
                    \node[text width=0.3cm] (q_3) [below = 0.3 of q_2]  {$\vdots$};        
                    
                    \path[->]
                    (p_0) edge[bend left, above]  node {$R_{p_0} R_v^* R_{q_0}$} (q_0)
                    (p_0) edge[bend left, left]  node {$R_{p_0} R_v^* R_{q_j}$} (q_2)
                    (p_2) edge[bend right, left]  node {$R_{p_i} R_v^* R_{q_0}$} (q_0)
                    (p_2) edge[bend right, below]  node {$R_{p_0} R_v^* R_{q_0}$} (q_2);

                \end{tikzpicture}
            
            \end{center}
            
            \caption{Результат устранения состояния $v$ для автомата, представленного на рисунке~\ref{fa:fa3}}
            \label{fa:fa4}
        \end{subfigure}
    \end{center}
    \caption{Общая схема устранения состояния $v$ при построении регулярного выражения по конечному автомату}
    \label{fa:fa_3_4}    
\end{figure}

После завершения основного цикла (когда в автомате осталось ровно два состояния), необходимо ещё раз объединить параллельные рёбра.
Общий вид получившегося автомата представлен на рисунке~\ref{fa:fa5}.
По такому автомату строим выражение вида \[(R_1^* \cdot (R_2 \cdot R_3^* \cdot R_4 )^* \cdot R_2 \cdot R_3^*,\] которое и будет ответом.
\begin{marginfigure}
    
    \begin{center}
        \begin{tikzpicture}

            \node[state, initial] (q_0)          {$0$};
            \node[state, accepting] (q_1) [right = of q_0]  {$1$};
            \path[->]
                (q_0) edge[bend left, above]  node {$R_2$} (q_1)
                (q_1) edge[bend left, below]  node {$R_4$} (q_0)
                (q_1) edge[loop above, above]  node {$R_3$} (q_1)
                (q_0) edge[loop above, above]  node {$R_1$} (q_0);

        \end{tikzpicture}

    \end{center}

    \caption{Общий вид автомата после завершения основного цикла}
    \label{fa:fa5}

\end{marginfigure}

\begin{example}
    Примеры.
\end{example}


\section{Лево(право)линейные грамматики}

Наложив некоторые ограничения на внешний вид правил грамматики можно получить грамматики, задающие регулярные языки.

\begin{definition}[Леволинейная грамматика]
    Грамматика $G=\langle \Sigma, N, P, S \rangle$ называется леволиненйной, если все её правила имеют вид
    \[N_i \to \alpha w,\]
    где $N_i \in N$, $\alpha \in \{\varepsilon\} \cup N$, $w \in \Sigma ^*$.
\end{definition}

\begin{definition}[Праволинейная грамматика]
    Грамматика $G=\langle \Sigma, N, P, S \rangle$ называется праволиненйной, если все её правила имеют вид
    \[N_i \to  w \alpha,\]
    где $N_i \in N$, $\alpha \in \{\varepsilon\} \cup N$, $w \in \Sigma ^*$.
\end{definition}

Ноам Хомский и Джордж Миллер в работе~\sidecite{chomsky1958finite} показали, что лево(право)линейные грамматики задают регулярные языки.
Приведём процедуры построения автомата по грамматике и наоборот, грамматики по автомату.

Пусть дан конечный автомат $M = \langle \Sigma, Q, q_s, Q_f, \delta \rangle$. По нему можно построить праволинейную грамматику $G=\langle \Sigma, N, S, P \rangle$, где
\begin{itemize}
    \item $N = Q$
    \item $P = \{ q_i \to t q_j \mid (q_i, t, q_j)\in \delta\} \cup \{ q_i \to \varepsilon \mid q_i \in Q_F\}$
    \item $S = q_s$
\end{itemize}

Аналогичным образом строится автомат по праволинейной грамматике.
Упростить процедуру можно если заранее привести правила к виду $N_i \to tN_j$, где $t\in \Sigma$, добавив необходимое количество новых нетерминалов:
правило вида $N_i \to twN_k$ преобразуется в два правила
\begin{align*}
    N_i & \to tN_l  \\
    N_l & \to wN_k,
\end{align*}
после чего аналогично преобразуется правило для $N_l$.

\begin{example}
Пример построения грамматики по автомату.
\end{example}

\begin{example}
Автомат по грамматике.
\end{example}

\section{Лемма о накачке}

Лемма о накачке для регулярных языков позволяет проверить, что заданный язык не является регулярным.

\begin{lemma}
    Пусть $L$~--- регулярный язык над алфавитом $\Sigma$, тогда существует такое $n$, что для любого слова $\omega \in L$, $|\omega| \geq n$ найдутся слова $x,y,z\in \Sigma^*$, для которых верно: $xyz = \omega, y\neq \varepsilon,|xy|\leq n$ и для любого $k \geq 0$  $xy^kz \in L$.
\end{lemma}

\begin{proofSketch}
    \begin{enumerate}
        \item Так как язык регулярный, то для него можно построить конечный автомат $M = \langle Q, q_s,Q_f, \delta, \Sigma \rangle$.
              В том числе, минимальный по количеству состояний.
        \item В качестве $n$ возьмём $|Q| + 1$.
        \item Легко заметить, что для любой цепочки $w \in L, |w| > n$ путь в автомате, соответствующий принятию данной цепочки, будет содержать хотя бы один цикл.
              Действительно, в ориентированном графе с $k$ вершинами (а именно таким является автомат по построению) максимальная длина пути без повторных посещений вершин (соответственно, без циклов) не больше $k - 1$.
        \item Выберем любой цикл. Он будет задавать искомые цепочки $x, y$ и $z$ так, как представлено на рисунке~\ref{fig:reg_lang_pumping_lemma}.
              Заметим, что вход в цикл и выход из него в общем случае могут не совпадать, что даёт несколько вариантов разбиения пути на части, и на рисунке представлен лишь один из возможных.
              \qedhere
    \end{enumerate}
\end{proofSketch}

\begin{figure}
    \caption{Иллюстрация идеи доказательства леммы о накачке для регулярных языков: любой путь в графе, длина которого достаточно большая, может быть разбит на три части из леммы ($x$~--- красный подпуть, $y$~--- синий, $z$~--- зелёный), а многократный проход по циклу $y$ позволяет \enquote{накачать} слово.}
    \label{fig:reg_lang_pumping_lemma}
    \begin{center}
        \begin{tikzpicture}[->]
            \node[state, initial] (q1) {$q_1$};
            \node[state, right = 2 of q1] (q2) {$q_2$};
            \node[state, accepting, right = 2 of q2] (q3) {$q_3$};
            \node[state, above = 2 of q2] (q4) {$q_4$};
            \draw (q1) edge[above, snake it] node{} (q2)
            (q2) edge[bend right, snake it, side by side={red}{blue}] node{} (q4)
            (q4) edge[bend right, snake it, color=blue] node[left]{$y$} (q2)
            (q4) edge[above, snake it, color=green] node[right]{$z$} (q3)
            (q1) edge[above, snake it, color=red] node{$x$} (q2)
            ;
        \end{tikzpicture}
    \end{center}

\end{figure}


\section{Замкнутость регулярных языков относительно теоретико-множественных операций}

\begin{theorem}
    Регулярные языки замкнуты относительно перечисленных ниже операций.
    \begin{enumerate}
        \item Пересечение
        \item Дополнение
        \item Обращение
        \item Разность
    \end{enumerate}
\end{theorem}

Линейная алгебра для работы с регулярными языками: пересечение, замыкание.

Построение пересечения через тензорное произведение автоматов.

Идея доказательства, что мы построили именно пересечение.

Пересечение через синхронный обход в ширину.

%\section{Вопросы и задачи}
%
%Построить базу.
%
%Научиться выполнять запросы через линейку.
