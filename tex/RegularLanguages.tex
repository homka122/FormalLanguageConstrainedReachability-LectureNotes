\setchapterpreamble[u]{\margintoc}
\chapter{Регулярные языки}
\tikzsetfigurename{RegularLanguages_}

В данном разделе мы обсудим регулярные языки~--- класс, лежащий на самом нижнем уровне иерархии Хомского.
Будут рассмотрены основные способы задания таких языков: \emph{регулярные выражения}, \emph{конечные автоматы}, \emph{лево(право)линейные грамматики}.
Обсудим основные свойства регулярных языков, такие как замкнутость относительно различных операций, а также различные свойства соответствующих автоматов и грамматик.

\section{Регулярные выражения}

Регулярные выражения~--- один из классических способов задать регулярный язык%
\sidenote{
    Замечание для программистов.
    Важно понимать, что речь идёт о формальной конструкции, а не о том, что называется регулярными выражениями в различных языках программирования или библиотеках, где под названием \enquote{регулярные выражения} могут скрываться конструкции, существенно более выразительные, чем обсуждаемые здесь.
}.
Основывается этот способ на предложении синтаксиса для описания \emph{регулярных множеств}%
\sidenote{Помним, что язык~--- это множество слов.}.

\begin{definition}[Регулярное множество]
    Регулярное множество (над алфавитом $\Sigma$) это:
    \begin{itemize}
        \item $\varnothing$;
        \item $\{\varepsilon\}$;
        \item $\{t\}$, $t \in \Sigma$;
        \item $R_1 \cup R_2$, где $R_1$ и $R_2$~--- регулярные множества;
        \item $R_1 \cdot R_2$, где $R_1$ и $R_2$~--- регулярные множества;
        \item $R^*$, где $R$~--- регулярное множество.
    \end{itemize}
\end{definition}

Для того, чтобы описывать такие множества, удобно пользоваться \emph{регулярными выражениями}.

\begin{definition}[Регулярное выражение]
    Регулярное выражение (над алфавитом $\Sigma$) это:
    \begin{itemize}
        \item $\varnothing$;
        \item $\varepsilon$;
        \item $t$, $t \in \Sigma$;
        \item $R_1 \mid R_2$, где $R_1$ и $R_2$~--- регулярные выражения;
        \item $R_1 \cdot R_2$, где $R_1$ и $R_2$~--- регулярные выражения;
        \item $R^*$, где $R$~--- регулярное выражение;
        \item $(R)$, где $R$~--- регулярное выражение.
    \end{itemize}
\end{definition}

Отметим несколько важных с прикладной точки зрения моментов.
Во-первых, часто используется расширенный синтаксис, в который добавляются конструкции не увеличивающие выразительную силу, но упрощающие запись.
Например, встречаются следующие расширения%
\sidenote{
    Существуют и другие, однако их мы не будем использовать и, соответственно, рассматривать.
    Читатель может вспомнить, что называется регулярными выражениями в его любимом языке программирования и попробовать самостоятельно выразить имеющиеся там конструкции через базовые.}.
\begin{itemize}
    \item $R? = R \mid \varepsilon$, где $R$~--- регулярное выражение.
    \item $R^+ = R \cdot R^*$, где $R$~--- регулярное выражение.
\end{itemize}

Во-вторых, конструкции $\varnothing$ и $\varepsilon$ используются крайне редко, особенно в случае расширенного синтаксиса, так как часто выражение, эквивалентное использующему данные конструкции, часто более компактно записывается с использованием расширенного синтаксиса.
В-третьих, оператор конкатенации часто опускается%
\sidenote{Как и знак умножения во многих математических записях.}.

Рассмотрим несколько примеров регулярных выражений.
\begin{example}
    Регулярное выражение $a$ задаёт регулярное множество $\{a\}$ и, соответственно, язык из единственного слова $a$.
\end{example}


\begin{example}
    Регулярное выражение $ab$ задаёт регулярное множество $\{ab\}$ и, соответственно, язык из единственного слова $ab$.
\end{example}


\begin{example}
    Регулярное выражение $a^*$ задаёт регулярное множество $$R = \bigcup_{i=0}^{\infty}{a^i} = \{\varepsilon, a, aa, aaa, \ldots \}$$ и, соответственно, бесконечный язык, содержащий для любого неотрицательного целого $n$ цепочку из символов $a$ длины $n$.
\end{example}

\begin{example}
    $a^*b$
\end{example}

\begin{example}
    $(a\mid b)^*$
\end{example}

\begin{example}
    $(ab)^*c?$
\end{example}

\section{Конечные автоматы}

\emph{Конечный автомат}~--- вычислительная машина, которая имеет конечный набор состояний и может совершать переходы между ними, читая входные данные.
Важно отметить, что ни какой дополнительной памяти классический конечный автомат не имеет%
\sidenote{Существуют автоматы с константной памятью, регистрами} и не производит дополнительных действий%
\sidenote{Автоматы с записью на ленту, и т.д.}.

\begin{definition}[Недетерминированный конечный автомат]
    \label{def:NondeterminicticFiniteAutomata}
    \emph{Недетерминированный конечный автомат} (НКА)~--- это пятёрка $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$, где
    \begin{itemize}
        \item $Q$~--- конечное множество состояний;
        \item $Q_S \subseteq= Q$~--- множество стартовых состояний;
        \item $Q_F \subseteq Q$~--- множество финальных состояний;
        \item $\delta \subseteq Q \times (\Sigma \cup \varepsilon) \times 2^Q$~--- функция переходов, а $\varepsilon \notin \Sigma$;
        \item $\Sigma$~--- конечный алфавит.
    \end{itemize}
\end{definition}

Так как нас интересуют конечные автоматы в контексте языков, то будем говорить, что на ленте автомата записано какое-то слово (или строка).
Иными словами, будем говорить, что автомат принимает на вход слово или строку.

Процесс вычислений, проделываемых конечным автоматом, удобно описывать в терминах переходов между \emph{конфигурациями}.

\begin{definition}[Конфигурация]
    Конфигурация $c$ конечного автомата $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$~--- это пара $(q, w)$, где $q\in Q$~--- это текущее состояние автомата, а $w \in \Sigma^*$~--- непросмотренная часть входной строки.
\end{definition}

\begin{definition}[Переход в НКА]
    Будем говорить, что автомат $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$ может перейти из конфигурации $c_1 = (q_1, w_1)$ в конфигурацию $c_2 = (q_2, w_2)$, если
    \[c_2 \in \{(q_2,w_2) \mid w_1 = aw_2, (q_1,a, q_2) \in \delta\} \cup \{(q_2,w_1) \mid (q_1, \varepsilon, q_2) \in \delta\}.\]
    Обозначать этот факт будем как $c_1 \to c_2$.
    Также будем считать, что на множестве конфигураций задано отношение перехода $(\to):(Q \times \Sigma^*)\times(Q \times \Sigma^*)$.
    
\end{definition}

\begin{definition}
    Транзитивное замыкание отношения перехода на конфигурациях будем обозначать следующим образом: $$ c_1 \to^* c_2. $$
    Альтернативно, в случае если $c_1 \to^* c_2$, будем говорить, что конфигурация $c_2$ \textit{достижима} из конфигурации $c_1$.
\end{definition}

Для удобства работы с недетерминированными автоматами расширим это отношение на множество конфигураций.

\begin{definition}
Будем говорить, что автомат может перейти из множества конфигураций $C_1$ в множество конфигураций $C_2$, если 
$$C_2 = \bigcup_{c_1 \in C_1} \{c_2 \mid c_1 \to c_2 \}.$$

Обозначать этот факт будем как  $C_1 \Rightarrow C_2 $.
\end{definition}

\begin{definition}
Транзитивное замыкание отношения перехода на множествах конфигураций будем обозначать следующим образом: $$ C_1 \Rightarrow^* C_2. $$
\end{definition}

Для описания работы автомата $M = \langle Q, Q_S, Q_F, \delta, \Sigma \rangle$ нам понадобятся следующие выделенные типы конфигураций.
\begin{itemize}
    \item Стартовая конфигурация $c_s = (q_s,w)$, $q_s \in Q_S$, $w$ --- цепочка, которая подаётся на вход автомату. 
    Для недетерминированного автомата естественно задать множество стартовых конфигурация $C_S = \bigcup_{q_s \in Q_S} (q_s,w)$.
    \item Финальная (принимающая) конфигурация $c_f = (q_f,\varepsilon)$, $q_f \in Q_F$.
\end{itemize}

Таким образом, работу автомата можно описать как последовательность переходов между множествами конфигураций. 
Работа начинается с множества стартовых конфигураций и завершается в следующих двух случаях.
\begin{enumerate}
    \item Очередное множество конфигураций содержит финальную конфигурацию:
    $$c_f \in C_S \text{ или } C_S \Rightarrow^* C_i, c_f \in C_i.$$ В этом случае говорят, что автомат \textit{принимает} входную строку.
    \item Очередное множество конфигураций пусто:
    $$C_0 = C_S \Rightarrow^* C_i \Rightarrow^* \varnothing, \text{ для любого } i: c_f \notin C_i.$$ 
    В этом случае говорят, что автомат \textit{не принимает} или \textit{отвергает} входную строку.
\end{enumerate} 

\begin{definition}
    Язык задаваемый автоматом $$\{w \mid \}$$
\end{definition}

Так как конфигурация полностью описывает состояние процесса вычислений, то не надо обрабатывать одну и ту же конфигурацию несколько раз. 
Это поможет при написании реального интерпретатора. 
Будем отслеживать уже посещённые (обработанные) конфигурации\footnote{Техника, аналогичная той, что применяется в обходах графов (обход в ширину, обход в глубину) для того, чтобы избежать повторного посещения вершин и, как следствие, зацикливания обхода. Более того, она типична для алгоритмов с рабочим множеством.}. 

\begin{example}
    Пример интерпретации конечного автомата.
\end{example}

\begin{definition}[Детерминированный конечный автомат]
    \label{def:DeterminicticFiniteAutomata}
    \emph{Детерминированный конечный автомат} (ДКА, Deterministic Finite Automata, DFA)~--- это пятёрка $M = \langle Q, q_S, Q_F, \delta, \Sigma \rangle$, где
    \begin{itemize}
        \item $Q$~--- конечное множество состояний;
        \item $q_S \in Q$~--- стартовое состояние;
        \item $Q_F \subseteq Q$~--- множество финальных состояний;
        \item $\delta \subseteq Q \times \Sigma \times Q$~--- функция переходов\footnote{Частично определённая.};
        \item $\Sigma$~--- конечный алфавит.
    \end{itemize}
\end{definition}

Отличие --- функция переходов. Нет переходов по $\varepsilon$ и из любого состояния не более одного перехода по символу.
Ещё стартовое состояние одно.

Заметим, что функцию переходов можно представить разными способами В зависимости от того, как именно представлена функция переходов: список троек, матрица, граф.

\begin{example}
    Пример КА.
    % \begin{tikzpicture}

    % \end{tikzpicture}
\end{example}

\begin{example}
    Пример интерпретации конечного автомата.
\end{example}

\section{Производные для регулярных языков}

Предложены в~\cite{Brzozowski1964}

По мотивам~\cite{OWENS_REPPY_TURON_2009}

\begin{itemize}
    \item $\partial_t(\varepsilon) = \varnothing$
    \item $\partial_t(\varnothing) = \varnothing$
    \item $\partial_t(x) = $
    \item $\partial_t(R_1 \cdot R_2) = \partial_t(R_1) \cdot (R_2) \mid $
    \item $\partial_t(R_1 \mid R_2) = \partial_t(R_1) \mid \partial_t(R_2) $
    \item $\partial_t(R^*) = $\footnote{Интересное упражнение --- показать это, расписав по определению звезду Клини.}
\end{itemize}

Проверка на пустоту (часто isNull).

\begin{itemize}
    \item $IsNull(\varepsilon) = false$
    \item $\partial_t(\varnothing) = \varnothing$
    \item $\partial_t(x) = $
    \item $\partial_t(R_1 \cdot R_2) = \partial_t(R_1) \cdot (R_2) \mid $
    \item $\partial_t(R_1 \mid R_2) = \partial_t(R_1) \mid \partial_t(R_2) $
    \item $\partial_t(R^*) = $\footnote{Интересное упражнение --- показать это, расписав по определению звезду Клини.}
\end{itemize}

Проверка пустоты регулярного языка\footnote{!!!!}


\section{Построение конечного автомата по регулярному выражению}
 
На производных.

Примеры.

\section{Построение регулярного выражения по конечному автомату}

Регулярное выражение будем строить по недетерминированному автомату специального вида: потребуем, чтобы у него было ровно одно стартовое состояние и ровно одно финальное\footnote{Любой автомат легко привести к такому виду: добавить состояния и $\varepsilon$-переходы}. 

Будем в цикле выполнять последовательно две операции.
Первая: объединение параллельных рёбер.
Вторая: устранение вершины $v$. За один шаг можем устранить любую кроме стартовой или финальной.
Цикл повторяется до тех пор, пока в автомате не останется ровно два состояния: стартовое и финальное.

До объединения параллельных рёбер
\begin{tikzpicture}

\node[state] (q_0)          {$q_i$};
\node[state] (q_1) [right of = q_0]  {$q_j$};
\path[->]
  (q_0) edge[bend left, above]  node {$R_1$} (q_1)
  (q_0) edge[bend right, below]  node {$R_2$} (q_1)
  ;
\end{tikzpicture}

После объединения параллельных рёбер.

\begin{tikzpicture}

    \node[state] (q_0)          {$q_i$};
    \node[state] (q_1) [right of = q_0]  {$q_j$};
    \path[->]
      (q_0) edge[above]  node {$R_1 \mid R_2$} (q_1)
      ;
    \end{tikzpicture}
    

\begin{tikzpicture}

\begin{scope}[node distance=10mm and 10mm]
   \node[state] (p_0)          {$p_0$};
   \node[text width=0.3cm]  (p_1) [below of = p_0] {$\vdots$}; 
   \node[state] (p_2) [below of = p_1]  {$p_i$};
   \node[text width=0.3cm] (p_3) [below of = p_2]  {$\vdots$};
\end{scope}

\node[state] (v_0) [right of = p_2] {$v$};

\begin{scope}[node distance=10mm and 10mm]
    \node[state] (q_2) [right of = v_0] {$q_j$};
    \node[text width=0.3cm] (q_1) [above of = q_2]  {$\vdots$};
    \node[state] (q_0) [above of = q_1]  {$q_0$};
    \node[text width=0.3cm] (q_3) [below of = q_2]  {$\vdots$};
\end{scope}

\path[->]
  (p_0) edge[above]  node {$R_{p_0}$} (v_0)
  (p_2) edge[below]  node {$R_{p_i}$} (v_0)
  (v_0) edge[right]  node {$R_{q_0}$} (q_0)
  (v_0) edge[above]  node {$R_{q_j}$} (q_2)
  (v_0) edge[loop above, above]  node {$R_v$} (v_0);
\end{tikzpicture}


\begin{tikzpicture}

    \begin{scope}[node distance=10mm and 10mm]
       \node[state] (p_0)          {$p_0$};
       \node[text width=0.3cm]  (p_1) [below of = p_0] {$\vdots$}; 
       \node[state] (p_2) [below of = p_1]  {$p_i$};
       \node[text width=0.3cm] (p_3) [below of = p_2]  {$\vdots$};
    \end{scope}
    
    \node[text width=0.3cm] (v_0) [right of = p_2] {};
    
    \begin{scope}[node distance=10mm and 40mm]
        \node[state] (q_2) [right of = v_0] {$q_j$};
        \node[text width=0.3cm] (q_1) [above of = q_2]  {$\vdots$};
        \node[state] (q_0) [above of = q_1]  {$q_0$};
        \node[text width=0.3cm] (q_3) [below of = q_2]  {$\vdots$};    
    \end{scope}
    
    \path[->]
      (p_0) edge[bend left, above]  node {$R_{p_0} R_v^* R_{q_0}$} (q_0)
      (p_0) edge[bend left, left]  node {$R_{p_0} R_v^* R_{q_j}$} (q_2)
      (p_2) edge[bend right, left]  node {$R_{p_i} R_v^* R_{q_0}$} (q_0)
      (p_2) edge[bend right, below]  node {$R_{p_0} R_v^* R_{q_0}$} (q_2);
    \end{tikzpicture}

$p_i v q_j$

$p_i \xrightarrow{R_{p_i}} v$
$v \xrightarrow{R_{q_j}} q_i$
$v \xrightarrow{R_v} v$
$p_i \xrightarrow{R_{p_i} \cdot R_v^* \cdot R_{q_j}} q_j$

По финальному автомату с двумя состояниями построим регулярное выражение, которое би будет ответом.

\begin{tikzpicture}
    \node[isosceles triangle,
    isosceles triangle apex angle=60,
    draw=none,fill=none,
    minimum size=2cm] (T60) at (3,0){};

\node[state, initial] (q_0)          {$0$};
\node[state, accepting] (q_1) [right of = q_0]  {$1$};
\path[->]
  (q_0) edge[bend left, above]  node {$R_2$} (q_1)
  (q_1) edge[bend left, below]  node {$R_4$} (q_0)
  (q_1) edge[loop right, right]  node {$R_3$} (q_1)
  (q_0) edge[loop above, above]  node {$R_1$} (q_0);
\end{tikzpicture}

$R_1^* \cdot (R_2 \cdot R_3^* \cdot R_4 \cdot R_1^*)^* \cdot R_2 \cdot R_3^*$



Примеры.



\section{Лево(право)линейные грамматики}

Наложив некоторые ограничения на внешний вид правил грамматики можно получить грамматики, задающие регулярные языки.

\begin{definition}[Леволинейная грамматика]
    Грамматика $G=\langle \Sigma, N, P, S \rangle$ называется леволиненйной, если все её правила имеют вид
    \[N_i \to \alpha w,\]
    где $N_i \in N$, $\alpha \in \{\varepsilon\} \cup N$, $w \in \Sigma ^*$.
\end{definition}

\begin{definition}[Праволинейная грамматика]
    Грамматика $G=\langle \Sigma, N, P, S \rangle$ называется праволиненйной, если все её правила имеют вид
    \[N_i \to  w \alpha,\]
    где $N_i \in N$, $\alpha \in \{\varepsilon\} \cup N$, $w \in \Sigma ^*$.
\end{definition}

Ноам Хомский и Джордж Миллер в работе~\sidecite{chomsky1958finite} показали, что лево(право)линейные грамматики задают регулярные языки.
Приведём процедуры построения автомата по грамматике и наоборот, грамматики по автомату.

Пусть дан конечный автомат $M = \langle \Sigma, Q, q_s, Q_f, \delta \rangle$. По нему можно построить праволинейную грамматику $G=\langle \Sigma, N, S, P \rangle$, где
\begin{itemize}
    \item $N = Q$
    \item $P = \{ q_i \to t q_j \mid (q_i, t, q_j)\in \delta\} \cup \{ q_i \to \varepsilon \mid q_i \in Q_F\}$
    \item $S = q_s$
\end{itemize}

Аналогичным образом строится автомат по праволинейной грамматике.
Упростить процедуру можно если заранее привести правила к виду $N_i \to tN_j$, где $t\in \Sigma$, добавив необходимое количество новых нетерминалов:
правило вида $N_i \to twN_k$ преобразуется в два правила
\begin{align*}
    N_i & \to tN_l  \\
    N_l & \to wN_k,
\end{align*}
после чего аналогично преобразуется правило для $N_l$.

Пример построения грамматики по автомату.

Автомат по грамматике.

\section{Лемма о накачке}

Лемма о накачке для регулярных языков позволяет проверить, что заданный язык не является регулярным.

\begin{lemma}
    Пусть $L$~--- регулярный язык над алфавитом $\Sigma$, тогда существует такое $n$, что для любого слова $\omega \in L$, $|\omega| \geq n$ найдутся слова $x,y,z\in \Sigma^*$, для которых верно: $xyz = \omega, y\neq \varepsilon,|xy|\leq n$ и для любого $k \geq 0$  $xy^kz \in L$.
\end{lemma}

\begin{proofSketch}
    \begin{enumerate}
        \item Так как язык регулярный, то для него можно построить конечный автомат $M = \langle Q, q_s,Q_f, \delta, \Sigma \rangle$.
              В том числе, минимальный по количеству состояний.
        \item В качестве $n$ возьмём $|Q| + 1$.
        \item Легко заметить, что для любой цепочки $w \in L, |w| > n$ путь в автомате, соответствующий принятию данной цепочки, будет содержать хотя бы один цикл.
              Действительно, в ориентированном графе с $k$ вершинами (а именно таким является автомат по построению) максимальная длина пути без повторных посещений вершин (соответственно, без циклов) не больше $k - 1$.
        \item Выберем любой цикл. Он будет задавать искомые цепочки $x, y$ и $z$ так, как представлено на рисунке~\ref{fig:reg_lang_pumping_lemma}.
              Заметим, что вход в цикл и выход из него в общем случае могут не совпадать, что даёт несколько вариантов разбиения пути на части, и на рисунке представлен лишь один из возможных.
              \qedhere
    \end{enumerate}
\end{proofSketch}

\begin{figure}
    \caption{Иллюстрация идеи доказательства леммы о накачке для регулярных языков: любой путь в графе, длина которого достаточно большая, может быть разбит на три части из леммы ($x$~--- красный подпуть, $y$~--- синий, $z$~--- зелёный), а многократный проход по циклу $y$ позволяет \enquote{накачать} слово.}
    \label{fig:reg_lang_pumping_lemma}
    \begin{center}
        \begin{tikzpicture}[->]
            \node[state, initial] (q1) {$q_1$};
            \node[state, right = 2 of q1] (q2) {$q_2$};
            \node[state, accepting, right = 2 of q2] (q3) {$q_3$};
            \node[state, above = 2 of q2] (q4) {$q_4$};
            \draw (q1) edge[above, snake it] node{} (q2)
            (q2) edge[bend right, snake it, side by side={red}{blue}] node{} (q4)
            (q4) edge[bend right, snake it, color=blue] node[left]{$y$} (q2)
            (q4) edge[above, snake it, color=green] node[right]{$z$} (q3)
            (q1) edge[above, snake it, color=red] node{$x$} (q2)
            ;
        \end{tikzpicture}
    \end{center}

\end{figure}


\section{Замкнутость регулярных языков относительно теоретико-множественных операций}

\begin{theorem}
    Регулярные языки замкнуты относительно перечисленных ниже операций.
    \begin{enumerate}
        \item Пересечение
        \item Дополнение
        \item Обращение
        \item Разность
    \end{enumerate}
\end{theorem}

Линейная алгебра для работы с регулярными языками: пересечение, замыкание.

Построение пересечения через тензорное произведение автоматов.

Идея доказательства, что мы построили именно пересечение.

Пересечение через синхронный обход в ширину.

%\section{Вопросы и задачи}
%
%Построить базу.
%
%Научиться выполнять запросы через линейку.
